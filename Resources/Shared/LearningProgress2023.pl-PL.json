{"Strings":{"Example":"Przyk\u0142ad","General knowledge":"Wiedza og\u00F3lna","HotChocolate":"Biblioteka HotChocolate","HotChocolate description":"Biblioteka HotChocolate pozwala na tworzenie GraphQL API w \u015Brodowisku .NET. GraphQL mo\u017Ce by\u0107 widziany jako alternatywa dla REST, kt\u00F3ra pozwala u\u017Cytkownikom API (i wymaga od nich) pytania o zestaw p\u00F3l przez nich potrzebny, w przeciwie\u0144stwie do REST, kt\u00F3ry zwraca w swojej odpowiedzi wszystkie dost\u0119pne pola. Biblioteka ta dobrze wsp\u00F3\u0142gra ze wstrzykiwaniem zale\u017Cno\u015Bci i wspiera 3 r\u00F3\u017Cne sposoby na definiowanie API: oparte na anotacjach, skupione na kodzie (Code-first) oraz skupione na schemacie (Schema-first).","JavaScript libs":"Biblioteki j\u0119zyka JavaScript","JS functions and arrays":"Funkcje i tablice w j\u0119zyku JavaScript","JS functions and arrays code":"\u0022use strict\u0022;\n\nfunction example()\n{\n    var numbers = [1,5,6,2,3,4,5,3,4,5];\n    console.log(\u0022Liczby: \u0022, numbers);\n    console.log(\u0022Liczby mniejsze od 5: \u0022, numbers.filter(n =\u003E n \u003C 5));\n    console.log(\u0022Do liczb dodano warto\u015B\u0107: \u0022, 20);\n    numbers.push(20);\n    numbers.sort();\n    console.log(\u0022Liczby posortowane alfabetycznie w miejscu: \u0022, numbers);\n    numbers.sort((a, b) =\u003E a - b);\n    console.log(\u0022Liczby posortowane numerycznie (rosn\u0105co): \u0022, numbers);\n}\n\nexample();","JS functions and arrays description":"Funkcje w j\u0119zyku JavaScript s\u0105 definiowane z u\u017Cyciem s\u0142owa kluczowego \u0027function\u0027 po kt\u00F3rym nast\u0119puje nazwa funkcji, nawias otwieraj\u0105cy, lista argument\u00F3w rozdzielona przecinkami, nawias zamykaj\u0105cy i potem cia\u0142o funkcji. Cia\u0142o funkcji mo\u017Ce by\u0107 zapisane wewn\u0105trz nawias\u00F3w klamrowych lub po operatorze \u0027=\u003E\u0027, zak\u0142adaj\u0105c, \u017Ce jest to pojedyncze wyra\u017Cenie. Je\u017Celi operator \u0027=\u003E\u0027 zostanie wykorzystany, to s\u0142owo kluczowe \u0027return\u0027 nie musi by\u0107 u\u017Cyte aby zwr\u00F3ci\u0107 warto\u015B\u0107.\nTablice s\u0105 definiowane wewn\u0105trz nawias\u00F3w kwadratowych, i mog\u0105 zawiera\u0107 r\u00F3\u017Cne typy przechowane w postaci sekwnecji element\u00F3w. Mog\u0105 to by\u0107 liczby, ci\u0105gi znak\u00F3w, obiekty i tablice, kt\u00F3re to s\u0105 indeksowane za pomoc\u0105 liczb ca\u0142kowitych, pocz\u0105wszy od 0.","JS objects":"Obiekty w j\u0119zyku JavaScript","JS objects code":"\u0022use strict\u0022;\n\nfunction example()\n{\n    var car = { price: 20000, isNew: false };\n    console.log(\u0022Oryginalny samoch\u00F3d: \u0022, car);\n    car.color = \u0022blue\u0022;\n    console.log(\u0022Pomalowany samoch\u00F3d: \u0022, car);\n    delete car.price;\n    console.log(\u0022Samoch\u00F3d bez ceny: \u0022, car);\n}\n\nexample();","JS objects description":"Obiekty w j\u0119zyku JavaScript s\u0105 definiowane wewn\u0105trz nawias\u00F3w klamrowych. Podczas przypisania obiektu do innej zmiennej, jego zawarto\u015B\u0107 nie jest kopiowana, tylko odwo\u0142anie do niego, przez co wskazuj\u0105 na ten sam obiekt, w przeciwie\u0144stwie do typ\u00F3w prostych, kt\u00F3re przechowuj\u0105 warto\u015Bci. W\u0142a\u015Bciwo\u015Bci obiektu mog\u0105 by\u0107 dodawane i usuwane dynamicznie.","JS types":"Typy w j\u0119zyku JavaScript","JS types code":"\u0022use strict\u0022;\n\nconsole.log(\u0022true jest typu: \u0022, typeof(true));\nconsole.log(\u00221 jest typu: \u0022, typeof(1));\nconsole.log(\u0027\u0022sentence\u0022 jest typu: \u0027, typeof(\u0022sentence\u0022))\nconsole.log(\u0022[1,2] jest typu: \u0022, typeof([1,2]));\nconsole.log(\u0027{ \u0022data\u0022: 123 } jest typu: \u0027, typeof({ \u0022data\u0022: 123 }));\nconsole.log(\u0022console.log jest typu: \u0022, typeof(console.log));","JS types description":"Typy w j\u0119zyku JavaScript dziel\u0105 si\u0119 na typy proste i typy obiektowe. Warto\u015Bci typ\u00F3w prostych s\u0105 niezmienne, a w\u015Br\u00F3d nich: Null, Undefined, Boolean, Number, BigInt, String oraz Symbol. Warto\u015Bci typ\u00F3w obiektowych s\u0105 zmienne, a w\u015Br\u00F3d nich typy takie jak funkcje czy tablice. Obiekty sk\u0142adaj\u0105 si\u0119 z w\u0142a\u015Bciwo\u015Bci, kt\u00F3re mog\u0105 zawiera\u0107 dane, funkcje albo inne obiekty.","NuGet packages":"Pakiety NuGet","Paged.js description":"Paged.js jest bibliotek\u0105 open-source, kt\u00F3ra umo\u017Cliwia tworzenie porz\u0105dnie wygl\u0105daj\u0105cych dokument\u00F3w PDF na podstawie stron HTML wraz z opcjonalnym podgl\u0105dem na samej witrynie.","Source":"\u0179r\u00F3d\u0142o","System.Text.Json":"Zmiany w przestrzeni nazw System.Text.Json","System.Text.Json description":"Pocz\u0105wszy od platformy .NET 7, kontrakty JSON mog\u0105 by\u0107 dostosowywane na dwa sposoby. Pierwszy z nich polega na utworzeniu nowej instancji typu DefaultJsonTypeInfoResolver i dodaniu akcji do w\u0142a\u015Bciwo\u015Bci Modifiers, kt\u00F3re to akcje b\u0119d\u0105 wywo\u0142ywane sekwencyjnie. Drugie podej\u015Bcie wymaga napisanie w\u0142asnego resolvera implementuj\u0105cego IJsonTypeInfoResolver, gdzie GetTypeInfo powinno zwraca\u0107 warto\u015B\u0107 null dla nieobs\u0142ugiwanych typ\u00F3w. Resolvery mog\u0105 by\u0107 \u0142\u0105czone ze sob\u0105, jednak\u017Ce tylko pierwszy o warto\u015Bci innej ni\u017C null zostanie u\u017Cyty dla danego typu.","TPH, TPC, TPT":"Podej\u015Bcia TPH, TPC, TPT - mapowanie hierarchii typ\u00F3w na tabele","TPH, TPC, TPT description":"Bior\u0105c pod uwag\u0119 mapowanie hierarchii typ\u00F3w na tabele, istniej\u0105 3 r\u00F3\u017Cne podej\u015Bcia: tabela na hierarchi\u0119 typ\u00F3w (TPH), tabela na konkretny typ (TPC) oraz tabela na typ (TPT). TPH dzia\u0142a poprzez tworzenie pojedynczej tabeli ze wszystkiml mo\u017Cliwymi w\u0142a\u015Bciwo\u015Bciami z hierarchii typ\u00F3w, a sprawuje si\u0119 najlepiej przy zapytaniach o encje wszystkich typ\u00F3w naraz. TPC tworzy osobn\u0105 tabel\u0119 dla ka\u017Cdego konkretnego typu i  najlepiej dzia\u0142a dla zapyta\u0144 o li\u015Bcie hierarchii. TPT definiuje osobn\u0105 tabel\u0119 dla ka\u017Cdego typu oraz jest najgorszym z rozwi\u0105za\u0144 z perspektywy wydajno\u015Bci, pomimo bycia intuicyjnie \u0027najczystszym\u0027 podej\u015Bciem.","Year2023":"2023"}}