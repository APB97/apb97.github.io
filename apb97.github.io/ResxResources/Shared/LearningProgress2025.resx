<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="C# 14 Features" xml:space="preserve">
    <value>C# 14 Features</value>
  </data>
  <data name="Example from documentation" xml:space="preserve">
    <value>Example from documentation</value>
  </data>
  <data name="General knowledge" xml:space="preserve">
    <value>General knowledge</value>
  </data>
  <data name="NuGet packages" xml:space="preserve">
    <value>NuGet packages</value>
  </data>
  <data name="Python Basics" xml:space="preserve">
    <value>Python Basics</value>
  </data>
  <data name="Year2025" xml:space="preserve">
    <value>2025</value>
  </data>
  <data name="Python 3" xml:space="preserve">
    <value>Python 3</value>
  </data>
  <data name="Poetry" xml:space="preserve">
    <value>Poetry - package manager for Python</value>
  </data>
  <data name="Using Poetry" xml:space="preserve">
    <value>Using Poetry</value>
  </data>
  <data name="pyproject.toml for Poetry" xml:space="preserve">
    <value>pyproject.toml for Poetry</value>
  </data>
  <data name="Using Poetry description" xml:space="preserve">
    <value>To add "pytest" dependency from CLI you can use "poetry add pytest" command. To run a script you can use "poetry run python script.py", or "poetry run pytest" for command line tool like "pytest". To install dependencies, use "poetry install", and to update dependencies to newest compatible versions, use"poetry update".</value>
  </data>
  <data name="pyproject.toml for Poetry description" xml:space="preserve">
    <value>If you want to use Poetry only for dependency management, you can specify "tool.poetry.package-mode=false". When your project uses custom repositories, you can specify them in [tool.poetry.source] section. Sections [tool.poetry.scripts] or [project.scripts] allow to specify tools available to run after installing the package. You can specify dependencies in groups, for instance for "test"group you can list them in: [tool.poetry.group.test.dependencies] section. There is an option to specify optional/extra dependencies in section [project.optional-dependencies].</value>
  </data>
  <data name="Python Basics description" xml:space="preserve">
    <value>Python syntax differs from C-like languages. In Python, scope of code is defined by indentation, "main" is not a special function, instead comparison of __name__ to "__main__" is used to determine if any code needs to run when launching the script. When declaring and assigning variables, there is no keyword like "var", "let", "const", and type of variable can be changed by simple assignment. However, often type hints are used to inform developer and the tooling about accepted or returned types.</value>
  </data>
  <data name="Python Advanced topics" xml:space="preserve">
    <value>Python - Advanced topics</value>
  </data>
  <data name="Python Advanced topics description" xml:space="preserve">
    <value>In Python, there are numerous advanced features. One of them are decorators, which allow to wrap one function call with another, which can be done with funtools.wraps decorator. Other one are context managers, which are quite often used when dealing with resources like files using syntax "with open("t.txt") as f:" which in turn calls functions __enter__ and __exit__ before and after code defined within, respectively.</value>
  </data>
  <data name="nameof support for unbound generic types description" xml:space="preserve">
    <value>This version added support for unbound generic types in the nameof expression. This means to get name of the type like List&lt;T&gt;, you can use "nameof(List&lt;&gt;)" instead of "nameof(List&lt;string&gt;)", or any other type parameters for generic type.</value>
  </data>
  <data name="New extension block for methods and properties" xml:space="preserve">
    <value>New extension block for methods and properties</value>
  </data>
  <data name="New extension block for methods and properties description" xml:space="preserve">
    <value>Extension methods and even properties can be defined using extension block.</value>
  </data>
  <data name="field contextual keyword" xml:space="preserve">
    <value>field contextual keyword</value>
  </data>
  <data name="field contextual keyword description" xml:space="preserve">
    <value>This contextual keyword allows to reference compiler-generated backing field in getters or setters of a property. It is one of a breaking changes if you used "field" as a variable/field name.</value>
  </data>
  <data name="EF Core Features" xml:space="preserve">
    <value>EF Core Features</value>
  </data>
  <data name="AsSplitQuery vs AsSingleQuery" xml:space="preserve">
    <value>AsSplitQuery vs AsSingleQuery</value>
  </data>
  <data name="AsSplitQuery vs AsSingleQuery description" xml:space="preserve">
    <value>Single queries may cause significant performance issues when multiple relations are JOINed in a query. One of the issues is cartesian explosion - when collection navigations are at the same level, this causes the database to return multiple rows per single entity as a result of cross product. Another issue is data duplication, even when using single collection navigation - each row returned contains all properties from both tables, however this can be improved by applying projection to reduce the amount of data. Using split queries, these issues can be resolved by using separate queries for each included collection navigation.</value>
  </data>
  <data name="nameof support for unbound generic types" xml:space="preserve">
    <value>nameof support for unbound generic types</value>
  </data>
</root>