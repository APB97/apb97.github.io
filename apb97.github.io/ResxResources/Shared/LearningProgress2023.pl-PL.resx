<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Example" xml:space="preserve">
    <value>Przykład</value>
  </data>
  <data name="General knowledge" xml:space="preserve">
    <value>Wiedza ogólna</value>
  </data>
  <data name="HotChocolate" xml:space="preserve">
    <value>Biblioteka HotChocolate</value>
  </data>
  <data name="HotChocolate description" xml:space="preserve">
    <value>Biblioteka HotChocolate pozwala na tworzenie GraphQL API w środowisku .NET. GraphQL może być widziany jako alternatywa dla REST, która pozwala użytkownikom API (i wymaga od nich) pytania o zestaw pól przez nich potrzebny, w przeciwieństwie do REST, który zwraca w swojej odpowiedzi wszystkie dostępne pola. Biblioteka ta dobrze współgra ze wstrzykiwaniem zależności i wspiera 3 różne sposoby na definiowanie API: oparte na anotacjach, skupione na kodzie (Code-first) oraz skupione na schemacie (Schema-first).</value>
  </data>
  <data name="JavaScript libs" xml:space="preserve">
    <value>Biblioteki języka JavaScript</value>
  </data>
  <data name="JS functions and arrays" xml:space="preserve">
    <value>Funkcje i tablice w języku JavaScript</value>
  </data>
  <data name="JS functions and arrays code" xml:space="preserve">
    <value>"use strict";

function example()
{
    var numbers = [1,5,6,2,3,4,5,3,4,5];
    console.log("Liczby: ", numbers);
    console.log("Liczby mniejsze od 5: ", numbers.filter(n =&gt; n &lt; 5));
    console.log("Do liczb dodano wartość: ", 20);
    numbers.push(20);
    numbers.sort();
    console.log("Liczby posortowane alfabetycznie w miejscu: ", numbers);
    numbers.sort((a, b) =&gt; a - b);
    console.log("Liczby posortowane numerycznie (rosnąco): ", numbers);
}

example();</value>
  </data>
  <data name="JS functions and arrays description" xml:space="preserve">
    <value>Funkcje w języku JavaScript są definiowane z użyciem słowa kluczowego 'function' po którym następuje nazwa funkcji, nawias otwierający, lista argumentów rozdzielona przecinkami, nawias zamykający i potem ciało funkcji. Ciało funkcji może być zapisane wewnątrz nawiasów klamrowych lub po operatorze '=&gt;', zakładając, że jest to pojedyncze wyrażenie. Jeżeli operator '=&gt;' zostanie wykorzystany, to słowo kluczowe 'return' nie musi być użyte, aby zwrócić wartość.
Tablice są definiowane wewnątrz nawiasów kwadratowych, i mogą zawierać różne typy przechowane w postaci sekwencji elementów. Mogą to być liczby, ciągi znaków, obiekty i tablice, które to są indeksowane za pomocą liczb całkowitych, począwszy od 0.</value>
  </data>
  <data name="JS objects" xml:space="preserve">
    <value>Obiekty w języku JavaScript</value>
  </data>
  <data name="JS objects code" xml:space="preserve">
    <value>"use strict";

function example()
{
    var car = { price: 20000, isNew: false };
    console.log("Oryginalny samochód: ", car);
    car.color = "blue";
    console.log("Pomalowany samochód: ", car);
    delete car.price;
    console.log("Samochód bez ceny: ", car);
}

example();</value>
  </data>
  <data name="JS objects description" xml:space="preserve">
    <value>Obiekty w języku JavaScript są definiowane wewnątrz nawiasów klamrowych. Podczas przypisania obiektu do innej zmiennej, jego zawartość nie jest kopiowana, tylko odwołanie do niego, przez co wskazują na ten sam obiekt, w przeciwieństwie do typów prostych, które przechowują wartości. Właściwości obiektu mogą być dodawane i usuwane dynamicznie.</value>
  </data>
  <data name="JS types" xml:space="preserve">
    <value>Typy w języku JavaScript</value>
  </data>
  <data name="JS types code" xml:space="preserve">
    <value>"use strict";

console.log("true jest typu: ", typeof(true));
console.log("1 jest typu: ", typeof(1));
console.log('"sentence" jest typu: ', typeof("sentence"))
console.log("[1,2] jest typu: ", typeof([1,2]));
console.log('{ "data": 123 } jest typu: ', typeof({ "data": 123 }));
console.log("console.log jest typu: ", typeof(console.log));</value>
  </data>
  <data name="JS types description" xml:space="preserve">
    <value>Typy w języku JavaScript dzielą się na typy proste i typy obiektowe. Wartości typów prostych są niezmienne, a wśród nich: Null, Undefined, Boolean, Number, BigInt, String oraz Symbol. Wartości typów obiektowych są zmienne, a wśród nich typy takie jak funkcje czy tablice. Obiekty składają się z właściwości, które mogą zawierać dane, funkcje albo inne obiekty.</value>
  </data>
  <data name="NuGet packages" xml:space="preserve">
    <value>Pakiety NuGet</value>
  </data>
  <data name="Paged.js description" xml:space="preserve">
    <value>Paged.js jest biblioteką open-source, która umożliwia tworzenie porządnie wyglądających dokumentów PDF na podstawie stron HTML wraz z opcjonalnym podglądem na samej witrynie.</value>
  </data>
  <data name="Source" xml:space="preserve">
    <value>Źródło</value>
  </data>
  <data name="System.Text.Json" xml:space="preserve">
    <value>Zmiany w przestrzeni nazw System.Text.Json</value>
  </data>
  <data name="System.Text.Json description" xml:space="preserve">
    <value>Począwszy od platformy .NET 7, kontrakty JSON mogą być dostosowywane na dwa sposoby. Pierwszy z nich polega na utworzeniu nowej instancji typu DefaultJsonTypeInfoResolver i dodaniu akcji do właściwości Modifiers, które to akcje będą wywoływane sekwencyjnie. Drugie podejście wymaga napisanie własnego resolvera implementującego IJsonTypeInfoResolver, gdzie GetTypeInfo powinno zwracać wartość null dla nieobsługiwanych typów. Resolvery mogą być łączone ze sobą, jednakże tylko pierwszy o wartości innej niż null zostanie użyty dla danego typu.</value>
  </data>
  <data name="TPH, TPC, TPT" xml:space="preserve">
    <value>Podejścia TPH, TPC, TPT - mapowanie hierarchii typów na tabele</value>
  </data>
  <data name="TPH, TPC, TPT description" xml:space="preserve">
    <value>Biorąc pod uwagę mapowanie hierarchii typów na tabele, istnieją 3 różne podejścia: tabela na hierarchię typów (TPH), tabela na konkretny typ (TPC) oraz tabela na typ (TPT). TPH działa poprzez tworzenie pojedynczej tabeli ze wszystkiml możliwymi właściwościami z hierarchii typów, a sprawuje się najlepiej przy zapytaniach o encje wszystkich typów naraz. TPC tworzy osobną tabelę dla każdego konkretnego typu i  najlepiej działa dla zapytań o liście hierarchii. TPT definiuje osobną tabelę dla każdego typu oraz jest najgorszym z rozwiązań z perspektywy wydajności, pomimo bycia intuicyjnie 'najczystszym' podejściem.</value>
  </data>
  <data name="Year2023" xml:space="preserve">
    <value>2023</value>
  </data>
</root>