{"Strings":{"Example":"Example","General knowledge":"General knowledge","HotChocolate":"HotChocolate library","HotChocolate description":"HotChocolate library allows creation of GraphQL APIs in .NET. GraphQL may be considered as an alternative to REST, which allows (and requires) API consumers to query only for fields they need, unlike REST, which returns all available fields in its response. This library works well with Dependecy Injection and supports 3 different ways of defining API: Annotation-based, Code-first and Schema-first.","JavaScript libs":"JavaScript libraries","JS functions and arrays":"JavaScript functions and arrays","JS functions and arrays code":"\u0022use strict\u0022;\n\nfunction example()\n{\n    var numbers = [1,5,6,2,3,4,5,3,4,5];\n    console.log(\u0022Numbers: \u0022, numbers);\n    console.log(\u0022Numbers less than 5: \u0022, numbers.filter(n =\u003E n \u003C 5))\n    console.log(\u0022Added value to numbers: \u0022, 20);\n    numbers.push(20);\n    numbers.sort();\n    console.log(\u0022In-place alphabetically sorted numbers: \u0022, numbers);\n    numbers.sort((a, b) =\u003E a - b);\n    console.log(\u0022In-place numerically sorted (ascending): \u0022, numbers);\n}\n\nexample();","JS functions and arrays description":"Functions in JavaScript are defined with \u0027function\u0027 keyword followed by name of the function, opening bracket, comma-separeted argument list, closing bracket and then the function body. A function body can be written within curly braces or after the arrow operator \u0027=\u003E\u0027, given it\u0027s a single statement. If the arrow operator is used, then return keyword doesn\u0027t have to be used to return a value.\nArrays can be defined within square brackets, and can contain different element types stored as a sequence. They can contain numbers, string, objects and arrays as their elements, which are indexed with whole numbers starting at 0.","JS objects":"Javascript objects","JS objects code":"\u0022use strict\u0022;\n\nfunction example()\n{\n    var car = { price: 20000, isNew: false };\n    console.log(\u0022Original car: \u0022, car);\n    car.color = \u0022blue\u0022;\n    console.log(\u0022Painted car: \u0022, car);\n    delete car.price;\n    console.log(\u0022Car without price: \u0022, car);\n}\n\nexample();","JS objects description":"Objects in JavaScript are defined within curly braces. When assigning an object to another variable, its content is not copied, only its reference, so they point to the same object, unlike primitive types which are stored as values. Properties of an object can be added and removed dynamically.","JS types":"JavaScript types","JS types code":"\u0022use strict\u0022;\n\nconsole.log(\u0022true is of type: \u0022, typeof(true));\nconsole.log(\u00221 is of type: \u0022, typeof(1));\nconsole.log(\u0027\u0022sentence\u0022 is of type: \u0027, typeof(\u0022sentence\u0022))\nconsole.log(\u0022[1,2] is of type: \u0022, typeof([1,2]));\nconsole.log(\u0027{ \u0022data\u0022: 123 } is of type: \u0027, typeof({ \u0022data\u0022: 123 }));\nconsole.log(\u0022console.log is of type: \u0022, typeof(console.log));","JS types description":"Types in JavaScript can be categorized into primitive types and object types. Primitive types\u0027 values are immutable, and these include: Null, Undefined, Boolean, Number, BigInt, String and Symbol. Object types\u0027 values are mutable, and these include types like functions and arrays. Objects consist of properties, which can contain data or functions or other objects.","NuGet packages":"NuGet packages","Paged.js description":"Paged.js is an open-source library that allows us to create well-looking PDF documents from our HTML pages, with optional preview right on the webpage.","Source":"Source","System.Text.Json":"Changes in System.Text.Json namespace","System.Text.Json description":"Starting with .NET 7, JSON contracts can be customized in two ways. First one is to create new instance of DefaultJsonTypeInfoResolver and add actions to its Modifiers property which will be called sequentially. Second method is to write a custom resolver implementing IJsonTypeInfoResolver, where GetTypeInfo should return null for unhandled types. Resolvers can be combined together, however only first non-null returning one will be used for any type.","TPH, TPC, TPT":"TPH, TPC, TPT approaches - mapping from type hierarchy to tables","TPH, TPC, TPT description":"When it comes to mapping type hierarchies to tables, there are 3 distinctive approaches: Table-per-Hierarchy (TPH), Table-per-Concrete-type (TPC) and Table-per-Type (TPT). TPH works by creating a single table with all possible properties from type hierarchy and works best when querying for entities of all types. TPC creates a different table for each concrete type and  works best when querying for leafs of the hierarchy. TPT defines a different table for each type and is the worst approach from the performace perspective, despite intiutively being the \u0027cleanest\u0027 solution.","Year2023":"2023"}}